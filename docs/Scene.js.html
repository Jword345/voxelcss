<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Scene.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-core_ColorFace-ColorFace.html">ColorFace</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-core_ColorFace-ColorFace.html#.loadFromSerial">loadFromSerial</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-core_Editor-Editor.html">Editor</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-core_ImageFace-ImageFace.html">ImageFace</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-core_ImageFace-ImageFace.html#.loadFromSerial">loadFromSerial</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-core_LightSource-LightSource.html">LightSource</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-core_Mesh-Mesh.html">Mesh</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-core_Mesh-Mesh.html#.loadFromSerial">loadFromSerial</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-core_Scene-Scene.html">Scene</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-core_Voxel-Voxel.html">Voxel</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module-core_World-World.html">World</a></span></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-common.html">common</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-common.html#~generateRotationMatrix">generateRotationMatrix</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-common.html#~hexToRgb">hexToRgb</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-common.html#~multiplyMatrices">multiplyMatrices</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-common.html#~rgbToHex">rgbToHex</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-core_ColorFace.html">core/ColorFace</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-core_Editor.html">core/Editor</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-core_ImageFace.html">core/ImageFace</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-core_LightSource.html">core/LightSource</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-core_Mesh.html">core/Mesh</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-core_Scene.html">core/Scene</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-core_Voxel.html">core/Voxel</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-core_World.html">core/World</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-events.html">events</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-meshes.html">meshes</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-positioned.html">positioned</a></span></li><li class="nav-heading">Events</li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="module-core_ColorFace.html#~event:change">change</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="module-core_ImageFace.html#~event:change">change</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="module-core_LightSource.html#~event:change">change</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="module-core_Mesh.html#~event:change">change</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="module-core_Scene.html#~event:pan">pan</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="module-core_Scene.html#~event:rotate">rotate</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="module-core_Scene.html#~event:zoom">zoom</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">Scene.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module core/Scene
 * @description Basically a camera that can rotate, pan, zoom and contain voxels
 * @requires events
**/
'use strict';

const {assign} = Object;
const {getDistance, isNumber, isShiftKey, not} = require('./common');
const events = require('./events');

const ZOOM_SCALING_FACTOR = 500;// larger --> slower zoom
const ZOOM_SCALING_FACTOR_MOBILE = 100;// larger --> slower zoom

const getX = e => (e.x || e.clientX || e.touches[0].pageX);
const getY = e => (e.y || e.clientY || e.touches[0].pageY);

// let setDebugText = val => (document.getElementById('debug').textContent = val);

module.exports = Scene;

/**
 * @name Scene
 * @constructor
 * @fires module:core/Scene~rotate
 * @fires module:core/Scene~pan
 * @fires module:core/Scene~zoom
 * @example &lt;caption>Add a light source to a scene&lt;/caption>
 * const Voxelcss = require('voxelcss');
 * let scene = new Voxelcss.Scene();
 * let position = [300, 300, 300];
 * let distance = 750;
 * let source = new Voxelcss.LightSource(position, distance);
 * scene.attach(document.body);
 * scene.addLightSource(source);
**/
function Scene() {
    let parentContainer;
    let sceneElement;
    let zoomElement;
    let cameraElement;
    let isAttached = false;
    let x = 0;
    let y = 0;
    let z = 0;
    let rotation = {x, y, z};
    let _pan = {x, y, z};
    let _zoom = 1;
    let mouse = {
        current: {x, y},
        shiftDown: false
    };
    let initialPinchDistance = 0;
    let canRotate = true;
    let canPan = true;
    let canZoom = true;
    let lightSources = [];
    let voxels = [];
    let getVoxels = () => voxels;
    let getRotation = () => rotation;
    let getLightSources = () => lightSources;
    let self = assign(this, events, {
        attach,
        detach,
        add, // voxel
        remove, // voxel
        getVoxels,
        pan,
        setPan,
        getPan,
        rotate,
        setRotation,
        getRotation,
        zoom,
        setZoom,
        getZoom,
        addLightSource,
        getLightSources,
        removeLightSource,
        canRotate: () => canRotate,
        canPan: () => canPan,
        canZoom: () => canZoom,
        enableRotate: () => (canRotate = true),
        enablePan: () => (canPan = true),
        enableZoom: () => (canZoom = true),
        disableRotate: () => (canRotate = false),
        disablePan: () => (canPan = false),
        disableZoom: () => (canZoom = false),
        isAttached: () => isAttached,
        getRotationX: () => rotation.x,
        getRotationY: () => rotation.y,
        getRotationZ: () => rotation.z,
        rotateX: val => rotateDimension('x', val),
        rotateY: val => rotateDimension('y', val),
        rotateZ: val => rotateDimension('z', val),
        setRotationX: val => setSceneDimensionRotation('x', val),
        setRotationY: val => setSceneDimensionRotation('y', val),
        setRotationZ: val => setSceneDimensionRotation('z', val),
        panX: val => panDimension('x', val),
        panY: val => panDimension('y', val),
        panZ: val => panDimension('z', val),
        setPanX: val => setSceneDimensionPan('x', val),
        setPanY: val => setSceneDimensionPan('y', val),
        setPanZ: val => setSceneDimensionPan('z', val),
        getElement: () => sceneElement,
        getParentElement: () => parentContainer,
        getInteractionState: val => (val ? mouse[val] : mouse),
        bind: () => {
            bindMouse();
            bindKeyboard();
        },
        unbind: () => {
            unbindMouse();
            unbindKeyboard();
        }
    });
    createSceneElement();
    bindMouse();
    bindKeyboard();

    function rotate(x, y, z) {
        rotateDimension('x', x);
        rotateDimension('y', y);
        rotateDimension('z', z);
        return self;
    }
    function setRotation(x, y, z) {
        setSceneDimensionRotation('x', x);
        setSceneDimensionRotation('y', y);
        setSceneDimensionRotation('z', z);
        updateSceneTransforms();
        return self;
    }
    function rotateDimension(dim, val) {
        if (isNumber(val)) {
            rotation[dim] += val;
            updateSceneTransforms();
        }
        return self;
    }
    function setSceneDimensionRotation(dim, val) {
        if (isNumber(val)) {
            rotation[dim] = val;
            updateSceneTransforms();
        }
        return self;
    }
    function pan(x, y, z) {
        panDimension('x', x);
        panDimension('y', y);
        panDimension('z', z);
    }
    function setPan(x, y, z) {
        setSceneDimensionPan('x', x);
        setSceneDimensionPan('y', y);
        setSceneDimensionPan('z', z);
        updateSceneTransforms();
        return self;
    }
    function panDimension(dim, val) {
        if (isNumber(val)) {
            _pan[dim] += val;
            updateSceneTransforms();
        }
        return self;
    }
    function setSceneDimensionPan(dim, val) {
        if (isNumber(val)) {
            _pan[dim] = val;
            updateSceneTransforms();
        }
        return self;
    }
    function getPan() {
        return _pan;
    }
    function zoom(val) {
        if (isNumber(val)) {
            _zoom += val;
            updateSceneTransforms();
        }
        return self;
    }
    function setZoom(val) {
        if (isNumber(val)) {
            _zoom = val;
            updateSceneTransforms();
        }
        return self;
    }
    function getZoom() {
        return _zoom;
    }
    function attach(elem) {
        if (!isAttached) {
            parentContainer = elem;
            elem.appendChild(sceneElement);
            isAttached = true;
        } else {
            throw 'Cannot attach currently attached scene';
        }
    }
    function detach() {
        if (isAttached) {
            isAttached = false;
            let {parentElement} = sceneElement;
            parentElement &amp;&amp; parentElement.removeChild(sceneElement);
        } else {
            throw 'Cannot detach currently detached scene';
        }
    }
    function add(voxel) {
        cameraElement.appendChild(voxel.getDomElement());
        voxels.push(voxel);
        voxel.setParentScene(self);
        if (lightSources.length !== 0) {voxel.updateLightSource(lightSources);}
    }
    function remove(voxel) {
        cameraElement.removeChild(voxel.getDomElement());
        voxels.splice(voxels.indexOf(voxel), 1);
        voxel.removeParentScene();
    }
    function addLightSource(source) {
        var index = lightSources.indexOf(source);
        if (index !== -1) {return false;}
        source.on('change move', updateVoxelLighting);
        lightSources.push(source);
        updateVoxelLighting();
        return true;
    }
    function removeLightSource(source) {
        var index = lightSources.indexOf(source);
        if (index === -1) {return false;}
        source.off('change move');
        lightSources.splice(index, 1);
        updateVoxelLighting();
        return true;
    }
    function createSceneElement() {
        sceneElement = document.createElement('div');
        zoomElement = document.createElement('div');
        cameraElement = document.createElement('div');
        sceneElement.setAttribute('class', 'voxelcss-scene');
        zoomElement.setAttribute('class', 'zoom');
        cameraElement.setAttribute('class', 'camera');
        sceneElement.appendChild(zoomElement);
        zoomElement.appendChild(cameraElement);
    }
    function onMouseDown(event) {
        updateMousePosition(event);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
    }
    function onMouseUp() {
        unbindMouse();
    }
    function onMouseMove(event) {
        let x = getX(event);
        let y = getY(event);
        let dx = x - mouse.current.x;
        let dy = y - mouse.current.y;
        mouse.current = {x, y};
        if (canPan &amp;&amp; mouse.shiftDown) {
            pan(dx, dy);
            updateSceneTransforms();
            self.trigger('pan', getData());
        } else if (canRotate) {
            const rotations = 2;
            const ROTATION_SCALING_FACTOR = Math.PI * 2 * rotations;
            rotation.y += dx / window.innerWidth * ROTATION_SCALING_FACTOR;
            rotation.x -= dy / window.innerHeight * ROTATION_SCALING_FACTOR;
            updateSceneTransforms();
            self.trigger('rotate', getData());
        }
    }
    function onTouchStart(event) {
        event.preventDefault();
        const touches = event.touches;
        updateMousePosition(event);
        window.addEventListener('touchmove', onTouchMove, {passive: false});
        if (touches.length > 1) {
            initialPinchDistance = getTouchDistance(touches);
        }
    }
    function onTouchMove(event) {
        event.preventDefault();
        let x = getX(event);
        let y = getY(event);
        let dx = x - mouse.current.x;
        let dy = y - mouse.current.y;
        mouse.current = {x, y};
        const touches = event.touches;
        if ((touches.length === 1) &amp;&amp; canRotate) {
            const rotations = 2;
            const ROTATION_SCALING_FACTOR = Math.PI * 2 * rotations;
            rotation.y += dx / window.innerWidth * ROTATION_SCALING_FACTOR;
            rotation.x -= dy / window.innerHeight * ROTATION_SCALING_FACTOR;
            updateSceneTransforms();
            self.trigger('rotate', getData());
        } else if ((touches.length === 2) &amp;&amp; canZoom) {
            const currentPinchDistance = getTouchDistance(touches);
            const zoomIn = (currentPinchDistance - initialPinchDistance) > 0;
            const sign = zoomIn ? 1 : -1;
            zoom(sign * currentPinchDistance / (initialPinchDistance * ZOOM_SCALING_FACTOR_MOBILE));
            initialPinchDistance = currentPinchDistance;
        } else if ((touches.length === 3) &amp;&amp; canPan) {
            pan(dx, dy);
            updateSceneTransforms();
            self.trigger('pan', getData());
        }
    }
    function onScroll(event) {
        if (canZoom) {
            zoom(event.deltaY / ZOOM_SCALING_FACTOR);
            event.preventDefault();
            self.trigger('zoom', getData());
        }
        return false;
    }
    function bindMouse() {
        sceneElement.addEventListener('mousedown', onMouseDown);
        sceneElement.addEventListener('mousewheel', onScroll);
        sceneElement.addEventListener('wheel', onScroll);
        sceneElement.addEventListener('touchstart', onTouchStart);
    }
    function bindKeyboard() {
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
    }
    function unbindMouse() {
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
    }
    function unbindKeyboard() {
        window.removeEventListener('keydown', onKeyDown);
        window.removeEventListener('keyup', onKeyUp);
    }
    function onKeyDown(event) {
        mouse.shiftDown = isShiftKey(event);
    }
    function onKeyUp(event) {
        mouse.shiftDown = not(isShiftKey)(event);
    }
    function getData() {
        return {
            rotation: getRotation(),
            pan: getPan(),
            zoom: getZoom(),
            target: self
        };
    }
    function getTouchDistance(touches) {
        const methods = [getX, getY];
        const [x0, y0] = methods.map(method => method(touches.item(0)));
        const [x1, y1] = methods.map(method => method(touches.item(1)));
        const dX = x1 - x0;
        const dY = y1 - y0;
        return getDistance(dX, dY);
    }
    function updateSceneTransforms() {
        let {x, y, z} = getRotation();
        let zoom = getZoom();
        let pan = getPan();
        cameraElement.style.transform = `rotateX(${x}rad) rotateY(${y}rad) rotateZ(${z}rad)`;
        zoomElement.style.transform = `scale(${zoom}, ${zoom}) translateX(${pan.x}px) translateY(${pan.y}px) translateZ(${pan.z}px)`;
        updateVoxelLighting();
    }
    function updateVoxelLighting() {
        if (lightSources.length !== 0) {
            voxels.forEach(voxel => voxel.updateLightSource(lightSources));
        }
    }
    function updateMousePosition(event) {
        const x = getX(event);
        const y = getY(event);
        mouse.current = {x, y};
    }
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.3</a> on Sun Aug 27 2017 14:55:49 GMT-0500 (CDT) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
